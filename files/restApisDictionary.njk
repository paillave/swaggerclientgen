//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

import * as dataAccess from "../tools/dataAccess";
import * as Models from "./models";

export interface IRestApisDictionary {
    [key: string]: {
        [key: string]: dataAccess.IRestApi;
    };
}

export const RestApisDictionary: IRestApisDictionary = {
{% for tag, elts in paths|toarray("path","definition")|selectmany("pathDefinition", "definition","method","definition")|groupby2("definition.tags.0") %}
    {{tag}}: {
{% for elt in elts %}
        {{elt.definition.operationId|replace("Async","")}}: {
            path: "{{elt.pathDefinition.path}}",
            method: "{{elt.method|upper}}"
        },
{% endfor %}
    },
{% endfor %}
};

export interface IReferences {
    [key: string]: { 
        [id: number]: string;
    };
}

export interface IModelWithReferences<T> {
    model: T;
    references: IReferences;
}
{% macro fieldTypeRefWithRef(ref) %}{{ref|replace("#/definitions/", "")|regexreplace("^ModelWithReferences\\[List\\[(.*)\\]\\]$","IModelWithReferences<[Models.I$1]>")|regexreplace("^ModelWithReferences\\[(.*)\\]$","IModelWithReferences<Models.I$1>")}}{% endmacro %}
{% macro fieldTypeRefWithoutRef(ref) %}Models.I{{ref|replace("#/definitions/", "")}}{% endmacro %}
{% macro fieldTypeRef(ref) %}{% if ref.startsWith("#/definitions/ModelWithReferences") %}{{fieldTypeRefWithRef(ref)}}{% else %}{{fieldTypeRefWithoutRef(ref)}}{% endif %}{% endmacro %}
{% macro fieldType(propertyDefinition) %}
{% if propertyDefinition.additionalProperties and propertyDefinition.type=="object" %}
{
        [key: string]: {{fieldType(propertyDefinition.additionalProperties)}};
        [key: number]: {{fieldType(propertyDefinition.additionalProperties)}};
    }{% elif propertyDefinition["$ref"] %}
{{fieldTypeRef(propertyDefinition["$ref"])}}{% elif propertyDefinition.type=="array" %}
[{{fieldType(propertyDefinition.items)}}]{% elif propertyDefinition.format=="date-time" %}
Date{% else %}
{{dicoType[propertyDefinition.type]|default(propertyDefinition.type)}}{% endif %}
{% endmacro %}
{% macro responseType(nodeResponses) %}{{fieldType(nodeResponses["200"].schema)}}{% endmacro %}
{% macro parameterType(nodeParameters) %}{}{% endmacro %}
{% macro api(tag, elt) %}{% if elt.definition.responses["200"].schema %}{{apiWithResponse(tag, elt)}}{% else %}{{apiWithNoResponse(tag, elt)}}{% endif %}{% endmacro %}
{% macro apiWithResponse(tag, elt) %}(state$: dataAccess.IUserStateObservable) => dataAccess.fetchData<{{responseType(elt.definition.responses)}}, {{parameterType(elt.definition.parameters)}}>(state$, RestApisDictionary.{{tag}}.{{elt.definition.operationId|replace("Async","")}}){% endmacro %}
{% macro apiWithNoResponse(tag, elt) %}(state$: dataAccess.IUserStateObservable) => dataAccess.fetchNoData<{{parameterType(elt.definition.parameters)}}>(state$, RestApisDictionary.{{tag}}.{{elt.definition.operationId|replace("Async","")}}){% endmacro %}

export const RestOperators = {
{% for tag, elts in paths|toarray("path","definition")|selectmany("pathDefinition", "definition","method","definition")|groupby2("definition.tags.0") %}
    {{tag}}: {
{% for elt in elts %}
        {{elt.definition.operationId|replace("Async","")}}: {{ api(tag, elt) }},
{% endfor %}
    },
{% endfor %}
};
